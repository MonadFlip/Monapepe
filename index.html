<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Staking & APR Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <!-- Using Roboto for a modern look -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    :root {
      --primary-color: #9c27b0;
      --primary-dark: #7b1fa2;
      --accent-color: #ab47bc;
      --background-color: #f5f5f5;
      --text-color: #333;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      background: linear-gradient(135deg, #d1c4e9, #9575cd);
      color: var(--text-color);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    .container {
      width: 95%;
      max-width: 1000px;
      margin: 20px auto;
      padding: 20px;
      background: rgba(255,255,255,0.97);
      border-radius: 12px;
      box-shadow: 0 12px 24px rgba(0,0,0,0.15);
      animation: fadeIn 1s ease;
    }
    header {
      text-align: center;
      margin-bottom: 30px;
    }
    header h1 {
      font-size: 2.8rem;
      margin: 0;
      color: var(--primary-color);
      text-shadow: 1px 1px 3px rgba(0,0,0,0.1);
    }
    header button {
      background: var(--primary-color);
      border: none;
      color: #fff;
      padding: 10px 20px;
      margin-top: 15px;
      border-radius: 5px;
      font-size: 1.1rem;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.3s ease;
    }
    header button:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
    }
    .card {
      background: #fff;
      border-radius: 10px;
      padding: 20px 25px;
      margin-bottom: 20px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
      transition: transform 0.3s ease;
    }
    .card:hover {
      transform: translateY(-5px);
    }
    .card h2 {
      margin-top: 0;
      color: var(--primary-color);
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 8px;
      font-size: 1.8rem;
    }
    .card p {
      margin: 12px 0;
      font-size: 1rem;
      line-height: 1.5;
    }
    .card button {
      background: var(--primary-color);
      border: none;
      color: #fff;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      transition: background 0.3s, transform 0.3s;
      margin-top: 10px;
    }
    .card button:hover {
      background: var(--primary-dark);
      transform: scale(1.03);
    }
    .input-group {
      display: flex;
      align-items: center;
      margin: 15px 0;
    }
    .input-group input {
      flex: 1;
      padding: 10px;
      font-size: 1rem;
      border: 1px solid #ddd;
      border-radius: 5px;
      margin-right: 15px;
      transition: border-color 0.3s;
    }
    .input-group input:focus {
      border-color: var(--primary-color);
      outline: none;
    }
    .input-group button {
      padding: 10px 15px;
      margin-right: 10px;
      background: var(--accent-color);
      border: none;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s, transform 0.3s;
    }
    .input-group button:hover {
      background: var(--primary-dark);
      transform: scale(1.03);
    }
    .button-group {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
    }
    .button-group a {
      background: var(--primary-color);
      color: #fff;
      text-decoration: none;
      padding: 10px 20px;
      border-radius: 5px;
      font-size: 1rem;
      transition: background 0.3s, transform 0.3s;
    }
    .button-group a:hover {
      background: var(--primary-dark);
      transform: scale(1.03);
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    @media (min-width: 768px) {
      .flex-row { display: flex; gap: 20px; }
      .flex-row .card { flex: 1; }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header with title and connect wallet button -->
    <header>
      <h1>Staking & APR Dashboard</h1>
      <button id="connectWallet">Connect Wallet</button>
      <!-- Display wallet address with prefix -->
      <div id="walletAddress"></div>
    </header>
    
    <!-- Public Dashboard: updates every 30 seconds -->
    <div class="card" id="publicDashboard">
      <h2>Dashboard</h2>
      <p>Price (in MON): <span id="price">-</span></p>
      <p>TVL (in MON): <span id="totalValue">-</span></p>
      <p>APR: <span id="apr">-</span>% / YEAR</p>
    </div>
    
    <!-- Wallet Dashboard: visible after wallet connection; auto-refreshes every 15 seconds -->
    <div class="card" id="walletDashboard" style="display: none;">
      <h2>Staking Interface</h2>
      <p>Token Balance: <span id="tokenBalance">0</span></p>
      <p>Your Staked Amount: <span id="userStaked">0</span></p>
      <p>Pending Reward: <span id="pendingReward">0</span></p>
      <button id="claimRewardButton">Claim Reward</button>
      <div class="input-group">
        <input type="number" id="stakeAmount" placeholder="Amount to stake">
        <button id="maxStake">Max</button>
        <button id="stakeButton">Stake</button>
      </div>
      <div class="input-group">
        <input type="number" id="unstakeAmount" placeholder="Amount to unstake">
        <button id="maxUnstake">Max</button>
        <button id="unstakeButton">Unstake</button>
      </div>
    </div>
    
    <!-- Quick Links Section -->
    <div class="card">
      <h2>Quick Links</h2>
      <div class="button-group">
        <a href="https://t.me/themonapepe" target="_blank">Telegram</a>
        <a href="https://www.defined.fi/mon-test/0x4a0a2b293a34c54d0965d23f8131a3d2c0b91290?quoteToken=token1&cache=ce97d&quoteCurrency=TOKEN" target="_blank">Defined.fi</a>
        <a href="https://testnet.nad.fun/tokens/0xB31be452692c5d7e2C1c3eD3FbD769a2723e3BEA" target="_blank">nad.fun</a>
      </div>
    </div>
  </div>
  
  <script>
    // --- RPC configuration for Monad Testnet ---
    const rpcUrl = "https://testnet-rpc.monad.xyz";
    const chainId = 10143;
    // Read-only provider for public dashboard data
    const readonlyProvider = new ethers.providers.JsonRpcProvider(rpcUrl, chainId);
    
    // Global variables for wallet-connected functionality
    let provider, signer, userAddress;
    let tokenContract, stakingContract;
    
    // Contract addresses
    const poolAddress      = "0x4a0A2B293A34c54d0965D23f8131A3D2c0b91290";  // Uniswap V2 pool
    const wETHAddress      = "0x3bb9AFB94c82752E47706A10779EA525Cf95dc27";  // wETH token
    const monapepeAddress  = "0xB31be452692c5d7e2C1c3eD3FbD769a2723e3BEA";  // Monapepe token
    const stakingAddress   = "0x9a6F85f4090292eE248B2C999a3E1422B1297177";  // Staking contract
    
    // Minimal ABIs for required contracts
    const poolABI = [
      "function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
      "function token0() external view returns (address)",
      "function token1() external view returns (address)"
    ];
    const stakingABI = [
      "function stake(uint256 amount) external",
      "function unstake(uint256 amount) external",
      "function claimReward() external",
      "function pendingReward(address user) external view returns (uint256)",
      "function getStakedAmount(address user) external view returns (uint256)",
      "function totalStaked() external view returns (uint256)"
    ];
    const tokenABI = [
      "function balanceOf(address owner) external view returns (uint256)",
      "function approve(address spender, uint256 amount) external returns (bool)",
      "function allowance(address owner, address spender) external view returns (uint256)"
    ];
    
    // Refresh public dashboard data (Price, TVL, APR) every 30 seconds
    async function refreshPublicDashboard() {
      try {
        const poolContract = new ethers.Contract(poolAddress, poolABI, readonlyProvider);
        const reserves = await poolContract.getReserves();
        const token0 = await poolContract.token0();
        const token1 = await poolContract.token1();
        let reserveWETH, reserveMonapepe;
        if (token0.toLowerCase() === wETHAddress.toLowerCase() && token1.toLowerCase() === monapepeAddress.toLowerCase()) {
          reserveWETH = reserves.reserve0;
          reserveMonapepe = reserves.reserve1;
        } else if (token0.toLowerCase() === monapepeAddress.toLowerCase() && token1.toLowerCase() === wETHAddress.toLowerCase()) {
          reserveWETH = reserves.reserve1;
          reserveMonapepe = reserves.reserve0;
        } else {
          console.error("Pool does not contain the expected tokens.");
          return;
        }
        // Convert reserves assuming 18 decimals
        const rWETH = parseFloat(ethers.utils.formatEther(reserveWETH));
        const rMonapepe = parseFloat(ethers.utils.formatEther(reserveMonapepe));
        const price = rWETH / rMonapepe;
        document.getElementById("price").innerText = price;
        
        const stakingContractRO = new ethers.Contract(stakingAddress, stakingABI, readonlyProvider);
        const totalStakedBN = await stakingContractRO.totalStaked();
        const totalStaked = parseFloat(ethers.utils.formatEther(totalStakedBN));
        document.getElementById("totalValue").innerText = (totalStaked * price).toFixed(6);
        
        const totalValue = totalStaked * price;
        let apr = 0;
        if (totalValue > 0) {
          apr = (8765 / totalValue) * 100;
        }
        document.getElementById("apr").innerText = apr.toFixed(2);
      } catch (error) {
        console.error("Error in public dashboard:", error);
        document.getElementById("price").innerText = "Error";
        document.getElementById("totalValue").innerText = "Error";
        document.getElementById("apr").innerText = "Error";
      }
    }
    
    // Refresh wallet dashboard data (Token Balance, Staked Amount, Pending Reward) every 15 seconds
    async function refreshWalletDashboard() {
      if (!tokenContract || !stakingContract || !userAddress) return;
      try {
        const tokenBalBN = await tokenContract.balanceOf(userAddress);
        document.getElementById("tokenBalance").innerText = ethers.utils.formatEther(tokenBalBN);
        
        const userStakedBN = await stakingContract.getStakedAmount(userAddress);
        document.getElementById("userStaked").innerText = ethers.utils.formatEther(userStakedBN);
        
        const pendingBN = await stakingContract.pendingReward(userAddress);
        document.getElementById("pendingReward").innerText = ethers.utils.formatEther(pendingBN);
      } catch (error) {
        console.error("Error in wallet dashboard:", error);
      }
    }
    
    // Combined function is removed – now separate intervals will update each section
    
    // Stake tokens function – manual update triggers wallet dashboard refresh
    async function stakeTokens() {
      const amount = document.getElementById("stakeAmount").value;
      if (!amount || isNaN(amount)) {
        console.error("Enter a valid amount.");
        return;
      }
      try {
        const parsedAmount = ethers.utils.parseEther(amount);
        const allowance = await tokenContract.allowance(userAddress, stakingAddress);
        if (allowance.lt(parsedAmount)) {
          const approveTx = await tokenContract.approve(stakingAddress, parsedAmount);
          await approveTx.wait();
        }
        const tx = await stakingContract.stake(parsedAmount);
        await tx.wait();
        console.log("Stake successful.");
        refreshWalletDashboard();
      } catch (error) {
        console.error("Error staking tokens:", error);
      }
    }
    
    // Unstake tokens function – manual update triggers wallet dashboard refresh
    async function unstakeTokens() {
      const amount = document.getElementById("unstakeAmount").value;
      if (!amount || isNaN(amount)) {
        console.error("Enter a valid amount.");
        return;
      }
      try {
        const tx = await stakingContract.unstake(ethers.utils.parseEther(amount));
        await tx.wait();
        console.log("Unstake successful.");
        refreshWalletDashboard();
      } catch (error) {
        console.error("Error unstaking tokens:", error);
      }
    }
    
    // Claim reward function – manual update triggers wallet dashboard refresh
    async function claimReward() {
      try {
        const tx = await stakingContract.claimReward();
        await tx.wait();
        console.log("Reward claimed successfully.");
        refreshWalletDashboard();
      } catch (error) {
        console.error("Error claiming reward:", error);
      }
    }
    
    // "Max" stake function
    async function maxStake() {
      try {
        const tokenBalBN = await tokenContract.balanceOf(userAddress);
        document.getElementById("stakeAmount").value = ethers.utils.formatEther(tokenBalBN);
      } catch (error) {
        console.error("Error fetching max stake:", error);
      }
    }
    
    // "Max" unstake function
    async function maxUnstake() {
      try {
        const userStakedBN = await stakingContract.getStakedAmount(userAddress);
        document.getElementById("unstakeAmount").value = ethers.utils.formatEther(userStakedBN);
      } catch (error) {
        console.error("Error fetching max unstake:", error);
      }
    }
    
    // Connect wallet function
    async function connectWallet() {
      if (!window.ethereum) {
        console.error("MetaMask not installed.");
        return;
      }
      try {
        await window.ethereum.request({ method: "eth_requestAccounts" });
        provider = new ethers.providers.Web3Provider(window.ethereum);
        provider.ens = null;
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        // Display wallet address with prefix "Connected: "
        document.getElementById("walletAddress").innerText = "Connected: " + userAddress;
        
        tokenContract = new ethers.Contract(monapepeAddress, tokenABI, signer);
        stakingContract = new ethers.Contract(stakingAddress, stakingABI, signer);
        
        // Show wallet dashboard and refresh its data immediately
        document.getElementById("walletDashboard").style.display = "block";
        refreshWalletDashboard();
      } catch (error) {
        console.error("Error connecting wallet:", error);
      }
    }
    
    // Event listeners for buttons
    document.getElementById("connectWallet").addEventListener("click", connectWallet);
    document.getElementById("stakeButton").addEventListener("click", stakeTokens);
    document.getElementById("unstakeButton").addEventListener("click", unstakeTokens);
    document.getElementById("maxStake").addEventListener("click", maxStake);
    document.getElementById("maxUnstake").addEventListener("click", maxUnstake);
    document.getElementById("claimRewardButton").addEventListener("click", claimReward);
    
    // Auto-refresh intervals:
    // Public Dashboard: every 30 seconds
    setInterval(refreshPublicDashboard, 30000);
    // Wallet Dashboard (if wallet is connected): every 15 seconds
    setInterval(refreshWalletDashboard, 15000);
    // Immediately refresh public dashboard on load
    refreshPublicDashboard();
  </script>
</body>
</html>
